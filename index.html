<meta charset="utf8">
<style>
	
	* {

		transition: all 0.2s ease-in-out;
	
	}

</style>

<p>
	<progress id="target_progress" value="0" max="1250" style="width:100%;">
</p>

<span id="target">...</span>

<p>
	<button onclick="start_record()">start record</button>
</p>

<p>

	<p id="target_player">...</p>

	<audio controls id="target_audio" style="width:50%">
		<source id="target_source">
	</audio>

</p>

<script type="text/javascript">

	let count = 0 // variable global

	;( async () => {

		recorder = await recordAudio() // recordAudio est une fonction async, je doit mettre un await devant

		// ü¢Å ici, l'instance MediaRecorder est lanc√© d√®s le chargement de la page
		// c'est pour √ßa que le navigateur web demande l'autorisation pour le micro
		// mais l'enregistrement n'a pas encore commenc√©

	})()

	//
	
	function recordAudio(){

		return new Promise(resolve => {

			navigator.mediaDevices.getUserMedia({ audio: true })

			.then( stream => {

				const mediaRecorder = new MediaRecorder(stream)

				// ü¢Å l'instance MediaRecorder est cr√©e ici

				const audioChunks = []

				mediaRecorder.addEventListener("dataavailable", event => {
					
					audioChunks.push(event.data)

					// ü¢Å pendant l'enregistrement, ce tableau ( list en python ) est rempli petit a petit
		
				})

				const start = () => {

					mediaRecorder.start()
				}

				const stop = () => {

					return new Promise( resolve => {

						mediaRecorder.addEventListener( "stop", async () => {

							const audioBlob = new Blob(audioChunks)

							// ü¢Å les donn√©es brut qui ont √©t√© enregistr√© par le micro
							
							const audioUrl = URL.createObjectURL(audioBlob)

							// ü¢Å une autre mani√®re de transformer les donn√©es brut en audio exploitable

							let bas64_audio = await convert_blob_to_base64(audioBlob)

							// ü¢Å je r√©cup√®re ici la chaine de charact√®res en format base64

							resolve( { audioUrl:audioUrl, bas64_audio:bas64_audio } )

							// ü¢Å je retourne comme valeur un objet ( dictionnaire en python ) contenant les cl√©s "audioUrl" et "bas64_audio"
							// et leurs valeurs respectives

							// resolve, c'est comme "return" mais pour les "promise" / function async

						})

						mediaRecorder.stop()

					})

				}

				resolve({ start, stop })

			})
		})
	}

	function convert_blob_to_base64(audioBlob){ // convertit les donn√©es brut en chaine de charact√®res en format base64

		// ü¢É new Promise, c'est la m√™me chose qu'une fonction asyncrone

		return new Promise( resolve => {

			let reader = new window.FileReader()
			reader.readAsDataURL(audioBlob) 
			reader.onloadend = function() {

				let result = reader.result
				resolve(result.split(",")[1])

			}

		})

	}

	async function start_record(){

		recorder.start() // lance l'enregistrement

		document.getElementById("target").innerText = "recording has started"

		let progress_value = 0 // valeur de la barre de progression
		
		let refreshId_progress = setInterval( function(){
		
			progress_value++
			
			document.getElementById("target_progress").value = progress_value
		
		}) // c'est √ßa qui fait avancer la barre de progression dans le temps

		// ü¢É ici c'est le timer, que j'ai mis a 5 secondes

		let refreshId = setInterval( async function(){

			console.log(count)
			count++

			if( count >= 5 ) { // au bout de 5 secondes, je stop la boucle

				clearInterval(refreshId) // stop les deux setInterval / loop / timer
				clearInterval(refreshId_progress) // stop les deux setInterval / loop / timer

				const result = await recorder.stop()

				// ü¢Å l'enregistrement est termin√©, je r√©cup√®re dans la variable "result" le r√©sultat de l'enregistrement

				// l'enregistrement est en deux format, audioUrl et base64 ( les deux marche tr√®s bien, j'utlise base64 )

				console.log(result)
		
				document.getElementById("target_source").src = "data:audio/ogg;base64," + result.bas64_audio

				document.getElementById("target_audio").load()

				//
		
				document.getElementById("target").innerText = "recording is complete"

				document.getElementById("target_player").innerText = "you can player your record here"

			}

		}, 1000 ) // 1000 ms = 1 seconde // la boucle setInterval s'execute tout les secondes

	}

</script>
